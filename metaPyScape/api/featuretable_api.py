# coding: utf-8

"""
    MetaboScape REST Application

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 2025b
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from metaPyScape.api_client import ApiClient


class FeaturetableApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_flag_to_feature(self, feature_id, flag, **kwargs):  # noqa: E501
        """Add Flag to Feature  # noqa: E501

        This operation adds a flag to a specific feature identified by the 'featureId' path parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_flag_to_feature(feature_id, flag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str feature_id: The unique identifier of the feature to which the flag is to be added. (required)
        :param str flag: The flag to be added to the feature. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_flag_to_feature_with_http_info(feature_id, flag, **kwargs)  # noqa: E501
        else:
            (data) = self.add_flag_to_feature_with_http_info(feature_id, flag, **kwargs)  # noqa: E501
            return data

    def add_flag_to_feature_with_http_info(self, feature_id, flag, **kwargs):  # noqa: E501
        """Add Flag to Feature  # noqa: E501

        This operation adds a flag to a specific feature identified by the 'featureId' path parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_flag_to_feature_with_http_info(feature_id, flag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str feature_id: The unique identifier of the feature to which the flag is to be added. (required)
        :param str flag: The flag to be added to the feature. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['feature_id', 'flag']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_flag_to_feature" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'feature_id' is set
        if ('feature_id' not in params or
                params['feature_id'] is None):
            raise ValueError("Missing the required parameter `feature_id` when calling `add_flag_to_feature`")  # noqa: E501
        # verify the required parameter 'flag' is set
        if ('flag' not in params or
                params['flag'] is None):
            raise ValueError("Missing the required parameter `flag` when calling `add_flag_to_feature`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'feature_id' in params:
            path_params['featureId'] = params['feature_id']  # noqa: E501

        query_params = []
        if 'flag' in params:
            query_params.append(('flag', params['flag']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/featuretable/feature/{featureId}/flag/create', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_annotation(self, body, feature_id, **kwargs):  # noqa: E501
        """Create a custom annotation for a specific feature  # noqa: E501

        With this operation, an annotation from any custom annotation outside of MetaboScape can be created for a Feature with a given 'featureId'. The 'candidate' parameter specifies the annotation candidate to be created. The annotation tool will be defined as \"External\" in MetaboScape.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_annotation(body, feature_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AnnotationCandidate body: The annotation candidate to be created. (required)
        :param str feature_id: The unique identifier of the feature for which the annotation is to be created. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_annotation_with_http_info(body, feature_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_annotation_with_http_info(body, feature_id, **kwargs)  # noqa: E501
            return data

    def create_annotation_with_http_info(self, body, feature_id, **kwargs):  # noqa: E501
        """Create a custom annotation for a specific feature  # noqa: E501

        With this operation, an annotation from any custom annotation outside of MetaboScape can be created for a Feature with a given 'featureId'. The 'candidate' parameter specifies the annotation candidate to be created. The annotation tool will be defined as \"External\" in MetaboScape.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_annotation_with_http_info(body, feature_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AnnotationCandidate body: The annotation candidate to be created. (required)
        :param str feature_id: The unique identifier of the feature for which the annotation is to be created. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'feature_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_annotation`")  # noqa: E501
        # verify the required parameter 'feature_id' is set
        if ('feature_id' not in params or
                params['feature_id'] is None):
            raise ValueError("Missing the required parameter `feature_id` when calling `create_annotation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'feature_id' in params:
            path_params['featureId'] = params['feature_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/featuretable/feature/{featureId}/annotation/create', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_feature_table(self, body, **kwargs):  # noqa: E501
        """Create a new Feature Table based on a project file  # noqa: E501

        This operation creates a new Feature Table based on the details provided in the 'projectFile' parameter. The returned data is in JSON format.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_feature_table(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str body: The YAML file that references a project and experiment, and defines the structure of one Feature Table. The Project ID and Experiment ID are mandatory to create a Feature Table! (required)
        :return: ProjectTaskSummary
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_feature_table_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_feature_table_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_feature_table_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a new Feature Table based on a project file  # noqa: E501

        This operation creates a new Feature Table based on the details provided in the 'projectFile' parameter. The returned data is in JSON format.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_feature_table_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str body: The YAML file that references a project and experiment, and defines the structure of one Feature Table. The Project ID and Experiment ID are mandatory to create a Feature Table! (required)
        :return: ProjectTaskSummary
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_feature_table" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_feature_table`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/featuretable/create', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectTaskSummary',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_lipid_species_annotations_with_method(self, body, annotation_method_uuid, **kwargs):  # noqa: E501
        """Create Lipid Species Annotations with Method  # noqa: E501

        This operation creates Lipid Species Annotations using a specific method identified by the 'annotationMethodUuid' path parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_lipid_species_annotations_with_method(body, annotation_method_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AnnotationConfiguration body: The configuration for the annotations. (required)
        :param str annotation_method_uuid: The unique identifier of the method for which the Lipid Species Annotations are to be created. (required)
        :return: list[AnnotationDetails]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_lipid_species_annotations_with_method_with_http_info(body, annotation_method_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.create_lipid_species_annotations_with_method_with_http_info(body, annotation_method_uuid, **kwargs)  # noqa: E501
            return data

    def create_lipid_species_annotations_with_method_with_http_info(self, body, annotation_method_uuid, **kwargs):  # noqa: E501
        """Create Lipid Species Annotations with Method  # noqa: E501

        This operation creates Lipid Species Annotations using a specific method identified by the 'annotationMethodUuid' path parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_lipid_species_annotations_with_method_with_http_info(body, annotation_method_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AnnotationConfiguration body: The configuration for the annotations. (required)
        :param str annotation_method_uuid: The unique identifier of the method for which the Lipid Species Annotations are to be created. (required)
        :return: list[AnnotationDetails]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'annotation_method_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_lipid_species_annotations_with_method" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_lipid_species_annotations_with_method`")  # noqa: E501
        # verify the required parameter 'annotation_method_uuid' is set
        if ('annotation_method_uuid' not in params or
                params['annotation_method_uuid'] is None):
            raise ValueError("Missing the required parameter `annotation_method_uuid` when calling `create_lipid_species_annotations_with_method`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'annotation_method_uuid' in params:
            path_params['annotationMethodUuid'] = params['annotation_method_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/featuretable/annotation/create/lipidspecies/{annotationMethodUuid}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AnnotationDetails]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_smart_formula_annotations_with_method(self, body, annotation_method_uuid, **kwargs):  # noqa: E501
        """Create SmartFormula Annotations with Method  # noqa: E501

        This operation creates SmartFormula Annotations using a specific method identified by the 'annotationMethodUuid' path parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_smart_formula_annotations_with_method(body, annotation_method_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[MainIonDetails] body: The main ion details for the annotations. (required)
        :param str annotation_method_uuid: The unique identifier of the method for which the SmartFormula Annotations are to be created. (required)
        :return: list[AnnotationDetails]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_smart_formula_annotations_with_method_with_http_info(body, annotation_method_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.create_smart_formula_annotations_with_method_with_http_info(body, annotation_method_uuid, **kwargs)  # noqa: E501
            return data

    def create_smart_formula_annotations_with_method_with_http_info(self, body, annotation_method_uuid, **kwargs):  # noqa: E501
        """Create SmartFormula Annotations with Method  # noqa: E501

        This operation creates SmartFormula Annotations using a specific method identified by the 'annotationMethodUuid' path parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_smart_formula_annotations_with_method_with_http_info(body, annotation_method_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[MainIonDetails] body: The main ion details for the annotations. (required)
        :param str annotation_method_uuid: The unique identifier of the method for which the SmartFormula Annotations are to be created. (required)
        :return: list[AnnotationDetails]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'annotation_method_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_smart_formula_annotations_with_method" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_smart_formula_annotations_with_method`")  # noqa: E501
        # verify the required parameter 'annotation_method_uuid' is set
        if ('annotation_method_uuid' not in params or
                params['annotation_method_uuid'] is None):
            raise ValueError("Missing the required parameter `annotation_method_uuid` when calling `create_smart_formula_annotations_with_method`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'annotation_method_uuid' in params:
            path_params['annotationMethodUuid'] = params['annotation_method_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/featuretable/annotation/create/smartformula/{annotationMethodUuid}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AnnotationDetails]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_target_list_annotations_with_method(self, body, annotation_method_uuid, **kwargs):  # noqa: E501
        """Create Target List Annotations with Method  # noqa: E501

        This operation creates Target List Annotations using a specific method identified by the 'annotationMethodUuid' path parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_target_list_annotations_with_method(body, annotation_method_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AnnotationConfiguration body: The configuration for the annotations. (required)
        :param str annotation_method_uuid: The unique identifier of the method for which the Target List Annotations are to be created. (required)
        :return: list[AnnotationDetails]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_target_list_annotations_with_method_with_http_info(body, annotation_method_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.create_target_list_annotations_with_method_with_http_info(body, annotation_method_uuid, **kwargs)  # noqa: E501
            return data

    def create_target_list_annotations_with_method_with_http_info(self, body, annotation_method_uuid, **kwargs):  # noqa: E501
        """Create Target List Annotations with Method  # noqa: E501

        This operation creates Target List Annotations using a specific method identified by the 'annotationMethodUuid' path parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_target_list_annotations_with_method_with_http_info(body, annotation_method_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AnnotationConfiguration body: The configuration for the annotations. (required)
        :param str annotation_method_uuid: The unique identifier of the method for which the Target List Annotations are to be created. (required)
        :return: list[AnnotationDetails]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'annotation_method_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_target_list_annotations_with_method" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_target_list_annotations_with_method`")  # noqa: E501
        # verify the required parameter 'annotation_method_uuid' is set
        if ('annotation_method_uuid' not in params or
                params['annotation_method_uuid'] is None):
            raise ValueError("Missing the required parameter `annotation_method_uuid` when calling `create_target_list_annotations_with_method`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'annotation_method_uuid' in params:
            path_params['annotationMethodUuid'] = params['annotation_method_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/featuretable/annotation/create/targetlist/{annotationMethodUuid}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AnnotationDetails]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_annotation(self, feature_id, annotation_id, **kwargs):  # noqa: E501
        """Delete a specific annotation for a specific feature  # noqa: E501

        This operation deletes a specific annotation for a specific feature identified by the 'featureId' path parameter. The parameter 'annotationId' determines the annotation to be deleted. Not all annotations for the feature are deleted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_annotation(feature_id, annotation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str feature_id: The unique identifier of the feature for which the annotation is to be deleted. (required)
        :param str annotation_id: The unique identifier of the annotation to be deleted. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_annotation_with_http_info(feature_id, annotation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_annotation_with_http_info(feature_id, annotation_id, **kwargs)  # noqa: E501
            return data

    def delete_annotation_with_http_info(self, feature_id, annotation_id, **kwargs):  # noqa: E501
        """Delete a specific annotation for a specific feature  # noqa: E501

        This operation deletes a specific annotation for a specific feature identified by the 'featureId' path parameter. The parameter 'annotationId' determines the annotation to be deleted. Not all annotations for the feature are deleted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_annotation_with_http_info(feature_id, annotation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str feature_id: The unique identifier of the feature for which the annotation is to be deleted. (required)
        :param str annotation_id: The unique identifier of the annotation to be deleted. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['feature_id', 'annotation_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_annotation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'feature_id' is set
        if ('feature_id' not in params or
                params['feature_id'] is None):
            raise ValueError("Missing the required parameter `feature_id` when calling `delete_annotation`")  # noqa: E501
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in params or
                params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `delete_annotation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'feature_id' in params:
            path_params['featureId'] = params['feature_id']  # noqa: E501
        if 'annotation_id' in params:
            path_params['annotationId'] = params['annotation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/featuretable/feature/{featureId}/annotation/delete/{annotationId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def generate_new_eics_and_eims(self, body, feature_table_id, **kwargs):  # noqa: E501
        """Generate new EICs and EIMs for a specific Feature Table  # noqa: E501

        This operation generates new Extracted Ion Chromatograms (EICs) and Extracted Ion Mobilograms (EIMs) for a specific Feature Table identified by the 'featureTableId' path parameter. The 'featureIds' parameter specifies the features for which the EICs and EIMs are to be generated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.generate_new_eics_and_eims(body, feature_table_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] body: The identifiers of the features for which the EICs and EIMs are to be generated. (required)
        :param str feature_table_id: The unique identifier of the Feature Table for which the EICs and EIMs are to be generated. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.generate_new_eics_and_eims_with_http_info(body, feature_table_id, **kwargs)  # noqa: E501
        else:
            (data) = self.generate_new_eics_and_eims_with_http_info(body, feature_table_id, **kwargs)  # noqa: E501
            return data

    def generate_new_eics_and_eims_with_http_info(self, body, feature_table_id, **kwargs):  # noqa: E501
        """Generate new EICs and EIMs for a specific Feature Table  # noqa: E501

        This operation generates new Extracted Ion Chromatograms (EICs) and Extracted Ion Mobilograms (EIMs) for a specific Feature Table identified by the 'featureTableId' path parameter. The 'featureIds' parameter specifies the features for which the EICs and EIMs are to be generated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.generate_new_eics_and_eims_with_http_info(body, feature_table_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] body: The identifiers of the features for which the EICs and EIMs are to be generated. (required)
        :param str feature_table_id: The unique identifier of the Feature Table for which the EICs and EIMs are to be generated. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'feature_table_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method generate_new_eics_and_eims" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `generate_new_eics_and_eims`")  # noqa: E501
        # verify the required parameter 'feature_table_id' is set
        if ('feature_table_id' not in params or
                params['feature_table_id'] is None):
            raise ValueError("Missing the required parameter `feature_table_id` when calling `generate_new_eics_and_eims`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'feature_table_id' in params:
            path_params['featureTableId'] = params['feature_table_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/featuretable/{featureTableId}/eicsandeims/create', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_flag_from_feature(self, feature_id, flag, **kwargs):  # noqa: E501
        """Remove Flag from Feature  # noqa: E501

        This operation removes a flag from a specific feature identified by the 'featureId' path parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_flag_from_feature(feature_id, flag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str feature_id: The unique identifier of the feature from which the flag is to be removed. (required)
        :param str flag: The flag to be removed from the feature. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_flag_from_feature_with_http_info(feature_id, flag, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_flag_from_feature_with_http_info(feature_id, flag, **kwargs)  # noqa: E501
            return data

    def remove_flag_from_feature_with_http_info(self, feature_id, flag, **kwargs):  # noqa: E501
        """Remove Flag from Feature  # noqa: E501

        This operation removes a flag from a specific feature identified by the 'featureId' path parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_flag_from_feature_with_http_info(feature_id, flag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str feature_id: The unique identifier of the feature from which the flag is to be removed. (required)
        :param str flag: The flag to be removed from the feature. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['feature_id', 'flag']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_flag_from_feature" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'feature_id' is set
        if ('feature_id' not in params or
                params['feature_id'] is None):
            raise ValueError("Missing the required parameter `feature_id` when calling `remove_flag_from_feature`")  # noqa: E501
        # verify the required parameter 'flag' is set
        if ('flag' not in params or
                params['flag'] is None):
            raise ValueError("Missing the required parameter `flag` when calling `remove_flag_from_feature`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'feature_id' in params:
            path_params['featureId'] = params['feature_id']  # noqa: E501

        query_params = []
        if 'flag' in params:
            query_params.append(('flag', params['flag']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/featuretable/feature/{featureId}/flag/remove', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_annotation_configuration_by_id(self, configuration_id, **kwargs):  # noqa: E501
        """Retrieve Annotation Configuration by ID  # noqa: E501

        This operation retrieves an Annotation Configuration identified by the 'configurationId' path parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_annotation_configuration_by_id(configuration_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str configuration_id: The unique identifier of the Annotation Configuration to be retrieved. (required)
        :return: AnnotationToolConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_annotation_configuration_by_id_with_http_info(configuration_id, **kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_annotation_configuration_by_id_with_http_info(configuration_id, **kwargs)  # noqa: E501
            return data

    def retrieve_annotation_configuration_by_id_with_http_info(self, configuration_id, **kwargs):  # noqa: E501
        """Retrieve Annotation Configuration by ID  # noqa: E501

        This operation retrieves an Annotation Configuration identified by the 'configurationId' path parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_annotation_configuration_by_id_with_http_info(configuration_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str configuration_id: The unique identifier of the Annotation Configuration to be retrieved. (required)
        :return: AnnotationToolConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['configuration_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_annotation_configuration_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'configuration_id' is set
        if ('configuration_id' not in params or
                params['configuration_id'] is None):
            raise ValueError("Missing the required parameter `configuration_id` when calling `retrieve_annotation_configuration_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'configuration_id' in params:
            path_params['configurationId'] = params['configuration_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/featuretable/annotation/configuration/{configurationId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AnnotationToolConfiguration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_annotation_methods_by_tool_id(self, tool_id, **kwargs):  # noqa: E501
        """Retrieve Annotation Methods by Tool ID  # noqa: E501

        This operation retrieves Annotation Methods for a specific tool identified by the 'toolId' path parameter ('TL' for Target List, 'LS' for Lipid Species, 'SL' for Spectral Library, 'SF' for SmartFormula).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_annotation_methods_by_tool_id(tool_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str tool_id: The unique identifier of the tool for which the Annotation Methods are to be retrieved. ('TL' for Target List, 'LS' for Lipid Species, 'SL' for Spectral Library, 'SF' for SmartFormula) (required)
        :return: list[AnnotationMethod]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_annotation_methods_by_tool_id_with_http_info(tool_id, **kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_annotation_methods_by_tool_id_with_http_info(tool_id, **kwargs)  # noqa: E501
            return data

    def retrieve_annotation_methods_by_tool_id_with_http_info(self, tool_id, **kwargs):  # noqa: E501
        """Retrieve Annotation Methods by Tool ID  # noqa: E501

        This operation retrieves Annotation Methods for a specific tool identified by the 'toolId' path parameter ('TL' for Target List, 'LS' for Lipid Species, 'SL' for Spectral Library, 'SF' for SmartFormula).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_annotation_methods_by_tool_id_with_http_info(tool_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str tool_id: The unique identifier of the tool for which the Annotation Methods are to be retrieved. ('TL' for Target List, 'LS' for Lipid Species, 'SL' for Spectral Library, 'SF' for SmartFormula) (required)
        :return: list[AnnotationMethod]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tool_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_annotation_methods_by_tool_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tool_id' is set
        if ('tool_id' not in params or
                params['tool_id'] is None):
            raise ValueError("Missing the required parameter `tool_id` when calling `retrieve_annotation_methods_by_tool_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tool_id' in params:
            path_params['toolId'] = params['tool_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/featuretable/annotation/methods/{toolId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AnnotationMethod]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_eics_for_feature(self, feature_id, **kwargs):  # noqa: E501
        """Retrieve EICs for a specific feature  # noqa: E501

        This operation retrieves Extracted Ion Chromatograms (EICs) for a specific feature identified by the 'featureId' path parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_eics_for_feature(feature_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str feature_id: The unique identifier of the feature for which the EICs are to be retrieved. (required)
        :return: list[FeatureEics]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_eics_for_feature_with_http_info(feature_id, **kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_eics_for_feature_with_http_info(feature_id, **kwargs)  # noqa: E501
            return data

    def retrieve_eics_for_feature_with_http_info(self, feature_id, **kwargs):  # noqa: E501
        """Retrieve EICs for a specific feature  # noqa: E501

        This operation retrieves Extracted Ion Chromatograms (EICs) for a specific feature identified by the 'featureId' path parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_eics_for_feature_with_http_info(feature_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str feature_id: The unique identifier of the feature for which the EICs are to be retrieved. (required)
        :return: list[FeatureEics]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['feature_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_eics_for_feature" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'feature_id' is set
        if ('feature_id' not in params or
                params['feature_id'] is None):
            raise ValueError("Missing the required parameter `feature_id` when calling `retrieve_eics_for_feature`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'feature_id' in params:
            path_params['featureId'] = params['feature_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/featuretable/feature/{featureId}/eics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FeatureEics]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_eims_for_feature(self, feature_id, **kwargs):  # noqa: E501
        """Retrieve EIMs for a specific feature  # noqa: E501

        This operation retrieves Extracted Ion Mobilograms (EIMs) for a specific feature identified by the 'featureId' path parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_eims_for_feature(feature_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str feature_id: The unique identifier of the feature for which the EIMs are to be retrieved. (required)
        :return: list[FeatureEims]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_eims_for_feature_with_http_info(feature_id, **kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_eims_for_feature_with_http_info(feature_id, **kwargs)  # noqa: E501
            return data

    def retrieve_eims_for_feature_with_http_info(self, feature_id, **kwargs):  # noqa: E501
        """Retrieve EIMs for a specific feature  # noqa: E501

        This operation retrieves Extracted Ion Mobilograms (EIMs) for a specific feature identified by the 'featureId' path parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_eims_for_feature_with_http_info(feature_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str feature_id: The unique identifier of the feature for which the EIMs are to be retrieved. (required)
        :return: list[FeatureEims]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['feature_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_eims_for_feature" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'feature_id' is set
        if ('feature_id' not in params or
                params['feature_id'] is None):
            raise ValueError("Missing the required parameter `feature_id` when calling `retrieve_eims_for_feature`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'feature_id' in params:
            path_params['featureId'] = params['feature_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/featuretable/feature/{featureId}/eims', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FeatureEims]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_feature(self, feature_id, **kwargs):  # noqa: E501
        """Retrieve a specific Feature based on its ID  # noqa: E501

        This operation retrieves a specific Feature identified by the 'featureId' path parameter. The returned data is in JSON format.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_feature(feature_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str feature_id: The unique identifier of the Feature to be retrieved. (required)
        :return: Feature
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_feature_with_http_info(feature_id, **kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_feature_with_http_info(feature_id, **kwargs)  # noqa: E501
            return data

    def retrieve_feature_with_http_info(self, feature_id, **kwargs):  # noqa: E501
        """Retrieve a specific Feature based on its ID  # noqa: E501

        This operation retrieves a specific Feature identified by the 'featureId' path parameter. The returned data is in JSON format.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_feature_with_http_info(feature_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str feature_id: The unique identifier of the Feature to be retrieved. (required)
        :return: Feature
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['feature_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_feature" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'feature_id' is set
        if ('feature_id' not in params or
                params['feature_id'] is None):
            raise ValueError("Missing the required parameter `feature_id` when calling `retrieve_feature`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'feature_id' in params:
            path_params['featureId'] = params['feature_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/featuretable/feature/{featureId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Feature',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_feature_ion_ms_spectra(self, feature_id, **kwargs):  # noqa: E501
        """Retrieve Feature Ion MS Spectra  # noqa: E501

        This operation retrieves a consensus MS Spectrum for every ion of a Feature identified by the 'featureId' path parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_feature_ion_ms_spectra(feature_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str feature_id: The unique identifier of the feature for which the Feature Ion MS Spectra are to be retrieved. (required)
        :return: list[FeatureIonMsSpectrumInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_feature_ion_ms_spectra_with_http_info(feature_id, **kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_feature_ion_ms_spectra_with_http_info(feature_id, **kwargs)  # noqa: E501
            return data

    def retrieve_feature_ion_ms_spectra_with_http_info(self, feature_id, **kwargs):  # noqa: E501
        """Retrieve Feature Ion MS Spectra  # noqa: E501

        This operation retrieves a consensus MS Spectrum for every ion of a Feature identified by the 'featureId' path parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_feature_ion_ms_spectra_with_http_info(feature_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str feature_id: The unique identifier of the feature for which the Feature Ion MS Spectra are to be retrieved. (required)
        :return: list[FeatureIonMsSpectrumInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['feature_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_feature_ion_ms_spectra" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'feature_id' is set
        if ('feature_id' not in params or
                params['feature_id'] is None):
            raise ValueError("Missing the required parameter `feature_id` when calling `retrieve_feature_ion_ms_spectra`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'feature_id' in params:
            path_params['featureId'] = params['feature_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/featuretable/feature/{featureId}/ms', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FeatureIonMsSpectrumInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_feature_ms_ms_spectra(self, feature_id, **kwargs):  # noqa: E501
        """Retrieve Feature MS/MS Spectra  # noqa: E501

        This operation retrieves an MS/MS spectrum (if available) for every ion of a specific feature identified by the 'featureId' path parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_feature_ms_ms_spectra(feature_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str feature_id: The unique identifier of the feature for which the Feature MS/MS Spectra are to be retrieved. (required)
        :return: list[FeatureIonMsMsSpectrumInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_feature_ms_ms_spectra_with_http_info(feature_id, **kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_feature_ms_ms_spectra_with_http_info(feature_id, **kwargs)  # noqa: E501
            return data

    def retrieve_feature_ms_ms_spectra_with_http_info(self, feature_id, **kwargs):  # noqa: E501
        """Retrieve Feature MS/MS Spectra  # noqa: E501

        This operation retrieves an MS/MS spectrum (if available) for every ion of a specific feature identified by the 'featureId' path parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_feature_ms_ms_spectra_with_http_info(feature_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str feature_id: The unique identifier of the feature for which the Feature MS/MS Spectra are to be retrieved. (required)
        :return: list[FeatureIonMsMsSpectrumInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['feature_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_feature_ms_ms_spectra" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'feature_id' is set
        if ('feature_id' not in params or
                params['feature_id'] is None):
            raise ValueError("Missing the required parameter `feature_id` when calling `retrieve_feature_ms_ms_spectra`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'feature_id' in params:
            path_params['featureId'] = params['feature_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/featuretable/feature/{featureId}/msms', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FeatureIonMsMsSpectrumInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_feature_ms_ms_spectra_deiso(self, feature_id, **kwargs):  # noqa: E501
        """Retrieve Feature MS/MS Deisotoped Spectra  # noqa: E501

        This operation retrieves a deisotoped MS/MS spectrum (if available) for every ion of a specific feature identified by the 'featureId' path parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_feature_ms_ms_spectra_deiso(feature_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str feature_id: The unique identifier of the feature for which the Feature MS/MS Deisotoped Spectra are to be retrieved. (required)
        :return: list[FeatureIonMsMsSpectrumInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_feature_ms_ms_spectra_deiso_with_http_info(feature_id, **kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_feature_ms_ms_spectra_deiso_with_http_info(feature_id, **kwargs)  # noqa: E501
            return data

    def retrieve_feature_ms_ms_spectra_deiso_with_http_info(self, feature_id, **kwargs):  # noqa: E501
        """Retrieve Feature MS/MS Deisotoped Spectra  # noqa: E501

        This operation retrieves a deisotoped MS/MS spectrum (if available) for every ion of a specific feature identified by the 'featureId' path parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_feature_ms_ms_spectra_deiso_with_http_info(feature_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str feature_id: The unique identifier of the feature for which the Feature MS/MS Deisotoped Spectra are to be retrieved. (required)
        :return: list[FeatureIonMsMsSpectrumInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['feature_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_feature_ms_ms_spectra_deiso" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'feature_id' is set
        if ('feature_id' not in params or
                params['feature_id'] is None):
            raise ValueError("Missing the required parameter `feature_id` when calling `retrieve_feature_ms_ms_spectra_deiso`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'feature_id' in params:
            path_params['featureId'] = params['feature_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/featuretable/feature/{featureId}/msmsdeiso', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FeatureIonMsMsSpectrumInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_feature_ms_spectra_details(self, feature_id, **kwargs):  # noqa: E501
        """Retrieve Feature MS Spectra Details  # noqa: E501

        This operation retrieves MS Spectra for every analysis of a specific Feature identified by the 'featureId' parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_feature_ms_spectra_details(feature_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str feature_id: The unique identifier of the feature for which the Feature MS Spectra Details are to be retrieved. (required)
        :return: list[FeatureIonMsSpectrumInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_feature_ms_spectra_details_with_http_info(feature_id, **kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_feature_ms_spectra_details_with_http_info(feature_id, **kwargs)  # noqa: E501
            return data

    def retrieve_feature_ms_spectra_details_with_http_info(self, feature_id, **kwargs):  # noqa: E501
        """Retrieve Feature MS Spectra Details  # noqa: E501

        This operation retrieves MS Spectra for every analysis of a specific Feature identified by the 'featureId' parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_feature_ms_spectra_details_with_http_info(feature_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str feature_id: The unique identifier of the feature for which the Feature MS Spectra Details are to be retrieved. (required)
        :return: list[FeatureIonMsSpectrumInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['feature_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_feature_ms_spectra_details" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'feature_id' is set
        if ('feature_id' not in params or
                params['feature_id'] is None):
            raise ValueError("Missing the required parameter `feature_id` when calling `retrieve_feature_ms_spectra_details`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'feature_id' in params:
            path_params['featureId'] = params['feature_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/featuretable/feature/{featureId}/ms/details', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FeatureIonMsSpectrumInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_feature_table(self, feature_table_id, **kwargs):  # noqa: E501
        """Fetches a specific Feature Table based on its ID  # noqa: E501

        This operation fetches a specific Feature Table identified by the 'featureTableId' path parameter. The returned data is in JSON format and contains an array of 'Feature' objects.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_feature_table(feature_table_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str feature_table_id: The unique identifier of the Feature Table to be retrieved. (required)
        :return: list[Feature]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_feature_table_with_http_info(feature_table_id, **kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_feature_table_with_http_info(feature_table_id, **kwargs)  # noqa: E501
            return data

    def retrieve_feature_table_with_http_info(self, feature_table_id, **kwargs):  # noqa: E501
        """Fetches a specific Feature Table based on its ID  # noqa: E501

        This operation fetches a specific Feature Table identified by the 'featureTableId' path parameter. The returned data is in JSON format and contains an array of 'Feature' objects.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_feature_table_with_http_info(feature_table_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str feature_table_id: The unique identifier of the Feature Table to be retrieved. (required)
        :return: list[Feature]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['feature_table_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_feature_table" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'feature_table_id' is set
        if ('feature_table_id' not in params or
                params['feature_table_id'] is None):
            raise ValueError("Missing the required parameter `feature_table_id` when calling `retrieve_feature_table`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'feature_table_id' in params:
            path_params['featureTableId'] = params['feature_table_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/featuretable/{featureTableId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Feature]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_intensity_matrix(self, feature_table_id, **kwargs):  # noqa: E501
        """Retrieve a intensity matrix of a Feature Table based on its ID  # noqa: E501

        Retrieve the intensity matrix of a Feature Table (i.e. a 2D array of intensities with dimensions based on the indices of Features and Analyses) identified by the 'featureTableId' path parameter. The returned data is in JSON format.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_intensity_matrix(feature_table_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str feature_table_id: The unique identifier of the Feature Table whose intensity matrix is to be retrieved. (required)
        :return: FeatureMatrix
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_intensity_matrix_with_http_info(feature_table_id, **kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_intensity_matrix_with_http_info(feature_table_id, **kwargs)  # noqa: E501
            return data

    def retrieve_intensity_matrix_with_http_info(self, feature_table_id, **kwargs):  # noqa: E501
        """Retrieve a intensity matrix of a Feature Table based on its ID  # noqa: E501

        Retrieve the intensity matrix of a Feature Table (i.e. a 2D array of intensities with dimensions based on the indices of Features and Analyses) identified by the 'featureTableId' path parameter. The returned data is in JSON format.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_intensity_matrix_with_http_info(feature_table_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str feature_table_id: The unique identifier of the Feature Table whose intensity matrix is to be retrieved. (required)
        :return: FeatureMatrix
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['feature_table_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_intensity_matrix" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'feature_table_id' is set
        if ('feature_table_id' not in params or
                params['feature_table_id'] is None):
            raise ValueError("Missing the required parameter `feature_table_id` when calling `retrieve_intensity_matrix`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'feature_table_id' in params:
            path_params['featureTableId'] = params['feature_table_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/featuretable/intensitymatrix/{featureTableId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FeatureMatrix',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def save_new_annotation_configuration(self, body, feature_table_id, **kwargs):  # noqa: E501
        """Save a new Annotation Configuration for a specific Feature Table  # noqa: E501

        This operation saves a new Annotation Configuration for a specific Feature Table identified by the 'featureTableId' path parameter. The 'config' parameter specifies the Annotation Configuration to be saved.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.save_new_annotation_configuration(body, feature_table_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AnnotationToolConfiguration body: The Annotation Configuration to be saved. (required)
        :param str feature_table_id: The unique identifier of the Feature Table for which the Annotation Configuration is to be saved. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.save_new_annotation_configuration_with_http_info(body, feature_table_id, **kwargs)  # noqa: E501
        else:
            (data) = self.save_new_annotation_configuration_with_http_info(body, feature_table_id, **kwargs)  # noqa: E501
            return data

    def save_new_annotation_configuration_with_http_info(self, body, feature_table_id, **kwargs):  # noqa: E501
        """Save a new Annotation Configuration for a specific Feature Table  # noqa: E501

        This operation saves a new Annotation Configuration for a specific Feature Table identified by the 'featureTableId' path parameter. The 'config' parameter specifies the Annotation Configuration to be saved.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.save_new_annotation_configuration_with_http_info(body, feature_table_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AnnotationToolConfiguration body: The Annotation Configuration to be saved. (required)
        :param str feature_table_id: The unique identifier of the Feature Table for which the Annotation Configuration is to be saved. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'feature_table_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method save_new_annotation_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `save_new_annotation_configuration`")  # noqa: E501
        # verify the required parameter 'feature_table_id' is set
        if ('feature_table_id' not in params or
                params['feature_table_id'] is None):
            raise ValueError("Missing the required parameter `feature_table_id` when calling `save_new_annotation_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'feature_table_id' in params:
            path_params['featureTableId'] = params['feature_table_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/featuretable/{featureTableId}/annotation/configuration/save', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
